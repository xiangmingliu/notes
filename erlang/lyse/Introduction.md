介绍
=============

现在我们开始Erlang的学习之旅, 阅读本书应该是你学习Erlang的第一步. 所以让我们来先热一下身.

首先， 我是在看了Miran Lipovača的 <<最佳途径学习Haskell>> 之后才有了写这本书的打算. 我认为
他的书非常出色地让一门语言变得有魅力, 并且让初学者在学习的过程中感到很亲切.因为和他相识的
缘故，我就写这本书的Erlang版本征求了他的意见，而他因为对Erlang也相当感兴趣， 所以他认为这
是个很不错的主意.

这就是我写作这本书的初衷. 当然还有其他方面的原因: 我发觉学习Erlang是一件非常困难的事情(网络
上的资料及其稀少, 因此你要购买各种书籍), 我认为Erlang社区会从类似LYAH风格的指南中获益匪浅.
还有不那么重要的一个原因， 我见到很多人看待Erlang的时候， 不论是赞美还是贬低， 都只是泛泛而
说.有些人甚至认为Erlang除了口号外什么也不是. 所以我想用一种方式去说服他们, 虽然我知道他们很
可能不会读到我的这本书.

那Erlang是什么？
==================

首先, Erlang是一门函数式编程语言。如果你使用过命令式编程语言，类似于i++这样的句子对你来说应
该很熟悉；在函数式编程语言中是不允许这么做的。事实上，改变任何变量的值都是被严令禁止的。这
听起来有点奇怪。但是回忆一下， 我们的数学课上就是这么说的:

```
y = 2
x = y + 3
x = 2 + 3
x = 5
```
我添加下面的代码：

```
x = 5 + 1
x = x
∴ 5 = 6
```
你以前可能对这一点也感到非常的疑惑。函数式编程语言意识到了这个问题：如果声明了x为5，在逻辑上
就不能再将它声明为6。这属于欺诈行为。这就是为什么对于相同的参数， 函数总是应该返回相同的结果：
```
x = add_two_to(3) = 5
∴ x = 5
```

对于相同的参数， 函数总是返回相同的结果， 这被称为引用透明， 正是基于这一点， 我们可以把
add_two_to(3) 替换为5, 因为3 + 2的结果总是5(你忘记了1 + 1并不总是等于2的事实了吗)。这意味着
我们可以将一堆的函数整合到一块以解决复杂的问题，同时我们能确保这中间没有一个函数会崩溃。这很
符合逻辑并且概念清晰， 难道不是吗？ 但是这其中仍然有一个问题：

```
x = today() = 2009/10/22
  -- wait a day --
x = today() = 2009/10/23
x = x
∴ 2009/10/22 = 2009/10/23
```
不！我们那完美的等号！它们瞬间出错了！ 我的函数怎么能每天都返回不同的结果呢？

很明显，有时候我们需要打破引用透明性。在这一点上，Erlang在保持函数式编程风格
的同时保持了实用主义的风格：遵守最核心的原则（引用透明性，避免可变的数据等），
当解决现实问题需要打破规则的时候则打破它们。

现在我们已经将Erlang定义为函数式编程语言，但是它也强调并发和高可用。为了能同时
执行大量的任务， Erlang使用了actor模型，每个actor都是虚拟机里面的一个独立进程。
简单的说， 如果你是Erlang世界里面的一个actor，你将会是一个孤独的人，坐在没有窗户
的房间里， 无时无刻不在注视着你的邮箱， 等待消息的到来。一旦得到一个消息，你将会
通过特定的方式对其做出反应：在收到账单的时候进行账单支付，当收到生日贺卡的时候回复
一张回谢贺卡， 忽略所有你不能理解的信件。

我们可以这样认识Erlang的actor模型： 每个人都坐在自己的房间里，它们都可以执行不同的任务。
每个人都只能通过写信的方式进行沟通。虽然这听起来会是一种很枯燥的生活（邮局服务的新时代到来了），
这意味这你可以同时请求很多的人为你去执行特定的任务，它们不会因为犯错而影响到其它人的工作；
除了你之外他们甚至意识不到其它人的存在（非常棒）。

为了达到这个类比，Erlang强迫我们使用actor（进程），这些进程除了给其它进程发送消息外不共享任何信息
每次通信都是显式的，可追溯和安全的。

当定义Erlang的时候，我们只是在语言的层面上考虑的， 但是从更广泛的意义上来看， Erlang并不仅仅如此：
Erlang同时也是一个完整的开发环境。代码被编译成字节码并在虚拟机中运行。所以Erlang也像java和ADD那样
可以在任何环境中运行。标准的版本中包含了开发工具（编译器，调试器，性能分析器，测试框架），开放电
信平台（OTP）框架，web服务器， 解析器产生器，mnesia数据库（分布式kv存储系统，支持嵌套的事务，可以
存储任何的Erlang类型）。 

虚拟机和库可以让我们对一个正在运行的系统进行代码更新而不会让程序崩溃，把代码发布到多台计算机上，通过
简单而强大的方式管理错误和缺陷。

我们将会在后面接触到大部分这类工具，并用它们来实现代码安全， 但是现在， 我想首先介绍一下Erlang中一些
与此相关的通用策略：任期崩溃。这并不像一架载着数百人的飞机失事那样听起来那么恐怖。而更像走钢丝表演者
下面铺着一张安全的网。尽管我们仍然需要避免错误，但是在大多数情况下我们不需要去检查每种类型或者错误条件。

Erlang的错误恢复能力， 使用actor模型组织代码，分布式扩展能力和并发听起来让人觉得非常了不起。那就让我们
继续移步到下一章吧...

不要盲从
=============

本书将会有很多黄橙色的和本节同名的小节（你将会很容易的认出它们）。Erlang现在的流行很大程度上是因为很多
热情洋溢的演讲， 但是这也很容易导致人们对它的认识偏离了它的本质。如果你是一个充满激情的初学者，这些提醒
能够让你脚踏实地。

第一个需要提醒的是广泛流传的Erlang由于其轻量级进程而拥有强大的扩展能力。Erlang的进程确实非常轻：你可以同时
拥有成千上万的进程， 但这并不意味着就应该这么做。例如， 在射击类游戏中将包括子弹在内所有的东西都建模成进程
是一件让人抓狂的事。这无异于搬起石头砸自己的脚。在actor之间发送消息还是有些许成本的，如果划分了太多的任务，
你将会让事情变得更慢。

我将会在适当的时候再讨论这点，请先记住一点， 不加思考地用并行来解决问题不能让它跑得更快。但是不用悲伤;采用上百
的进程来解决问题有时候还是挺有用的！ 只是这并不能适用于所有的情况。

Erlang也被称为随着CPU的核数增加性能得到同比例的性能提升， 但是很多时候并不是这样的： 这种可能性是存在的，但是对
很多问题，我们并不能将所有的东西都建模成的并行

我们还需要记住一些东西： 虽然Erlang在某些方面很擅长， 但这并不是说采用其它的技术无法达到同样的效果。反之也成立；
我们需要正确的评估每个问题，并选择合适的工具。Erlang不是银弹， 它也有它糟糕的一面， 尤其是在图像和信号处理， 
操作系统设备驱动等方面。它的长处在于构建大型的服务器软件（例如：队列，map-reduce），在和其它语言的集成中专干累活，
高级协议的实现等。在中间的领域则取决于你自己的选择，你不必将Erlang限制在服务器编程中， 在其它领域已经有人用Erlang
做出了杰出的事情。一个例子就是IANO, UNICT团队建造的一个机器人，它们使用Erlang来实现它们的人工智能并在2009年欧洲
机器人大赛中斩获银奖。另外一个例子是Wings3D， 一个使用Erlang编写的3D建模软件。

前期准备
===============

你仅仅需要准备一个文本编辑器和Erlang环境。你可以从Erlang的官方网站上获得源码或者二进制安装包。
我不会过多的介绍安装细节，对于windows环境，运行下载下来的安装包即可。别忘记在PATH环境
变量中配置Erlang目录， 以便能够在命令行中运行erlang命令。

在基于Debian的linux系统中， 你可以运行apt-get install erlang 命令进行安装。在Fedora（如果
你安装了yum）中，可以运行yum install erlang进行安装。但是这些仓库上面的安装包经常都不是最
新的；使用过时的版本可能让你得到和本书不太一样的结果， 在某些应用上可能性能有所下降。因此
我鼓励从源码进行安装。安装的时候阅读包内的README文件并借助Google， 我相信你能比我做得更好。

在FreeBSD， 你可以有很多选项， 如果你使用portmaster， 你可以输入命令portmaster lang/erlang
进行安装。对于标准的port， 你应该`cd /usr/ports/lang/erlang; make install clean`。最后，
如果想使用packages， 运行run `pkg_add -rv erlang`。

如果你在OSX上，你可以通过`$ brew install erlang` 或者`$ port install erlang`（如果你更喜欢
MacPorts）来安装

Erlang Solutions 公司为大多数的操作系统提供了安装包， 通常它们都工作得非常棒。

```
注： 写这本书的时候， 我使用的Erlang版本是R13B+, 所以为了获得更好的效果， 你也应该使用
这个版本或者更高的版本。
```

怎么获取帮助
=====================

如果你使用linux， 你可以通过 `erl -man lists` 访问lists模块的技术文档。

在windows上， 安装的时候应该将html文档也安装上，你可以从官网上下载

如果你想保持干净的代码风格的话， 可以在[这里](http://www.erlang.se/doc/programming_rules.shtml)
找到号的编码风格。本书的代码也会尽量遵守这里的风格

当觉得技术细节满足不了我们的时候，我们可以访问官方的[邮件列表](http://www.erlang.org/static/doc/mailinglist.html)
和[#erlang](irc://irc.freenode.net/erlang)频道

如果你想找一些cookbook或者一些既定方案， [trapexit](http://trapexit.org)是个不错的地方, 他们还将
erlang的邮件列表镜像成了一个论坛和不错的wiki, 这对我们很有用。























































































