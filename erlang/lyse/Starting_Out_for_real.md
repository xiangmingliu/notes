真正的开始
================
<font color="#D1E9E9">
```
Erlang是一门相对小而且简单的语言（就像C之于C++）。语言里面只内置了一些基本的数据类型，
因此，本章就能覆盖其中的大部分。强烈建议阅读本章， 因为它解释了语言的基本构造块，今后
使用Erlang写程序就仰赖它们了。
```
</font>

数字
------------

在Erlang shell中，**表达式必须以(.)后跟一个空白符（换行，空格等）结束，否则的话它们不会被执行**，你可以使用(,)来分割表达式
但是只有最后一个表达式的结果会被显示（其它的表达式仍然被执行了）。这对大多数人来说都不是一种常见的语法。这种语法形式是由于
Erlang早期是用Prolog来实现的，Prolog是一门逻辑编程语言。

使用上一章的方法打开Erlang shell，让我们输入一些东西瞧瞧！

```
Erlang/OTP 17 [erts-6.4.1.5] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.4.1.5  (abort with ^G)
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472
3> .
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
```
你可能已经注意到Erlang不在意你是输入了浮点数还是整数：在算术运算中两种类型都是被支持的。整型和浮点型是唯一的
两种Erlang的数学操作对象，Erlang会为我们透明地处理这两种类型。但是， 请使用div来作整除，使用rem来做求余运算。

我们可以在单个表达式中使用多个操作符，数学运算符之间遵守正常的优先级规则。

```
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
```

如果你想表达10进制以外的整数，请输入Base#Value(基数的范围在2..36)

```
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
```
太棒了！ Erlang有着和你桌子边角上那个有着怪异语法的计算器同样的能力。
这太让人激动了！

变量不可变
=========

做运算我们已经没有问题了， 但是如果我们不能将运算结果保存起来，这意义也不大。
为此，我们将使用变量。如果你阅读了本书的介绍部分，则你已经知道了变量在函数式
编程中是不可变的。变量的基本行为可以用这7个表达式来演示（请注意变量以大写字母开头）：

```
1> One.
1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
```

这些命令给我们的第一点提示是你只能给变量赋值一次；然后你可以假装给一个变量赋值，但是值
要和它已有的值相同。如果它不同， Erlang将会抱怨。我们正确地观察到了这点，但是解释它是一件
相当复杂的事， 因为它依赖于=操作符。=操作符（指的不是变量）负责比较两个值，如果两边的值不等，
它将向我们发出抱怨。如果两边的值相等，它就把这个值返回:

```
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
```

=操作符和变量合在一起使用所表达的意思是如果变量是未绑定的（没有值和它关联），Erlang会自动将右边的值
绑定到左边的变量上。因此后续的比较会成功，变量在内存中持有该值。

=号操作符的这种行为是“模式匹配”的基础， 很多的函数式编程语言里面都有模式匹配，但是这在Erlang里面更加
灵活和完整。我们在本章元组和列表的部分和后续章节的函数部分再详细谈论这点。

这7个命令给我们的一个另外的提示是变量必须以大写字母开头. 第7个命令因为two是以小写字母开头的而失败了。
从技术上将， 变量也可以以('_')，开头，它用来表示那些我们不关心其值， 但为了完整性考虑，我们仍然将它写出来。

你可以只用一个下划线来表示变量：

```
10> _ = 14 + 3.
17
11> _.
* 1: variable '_' is unbound
```

不像其它类型的变量，它不会存储任何的值。现在它对我们来说没有任何用处，但是当我们需要它的时候， 你就应该知道
有这么一个东西

```
注意： 如果你在shell里面作测试的时候把错误的值赋给了变量， 可以使用函数f(Variable).来擦除变量。使用f().来擦除
左右的变量。

这个函数只在你作测试的时候使用， 它只能在shell中使用。当编写真正的程序的时候，我们不能使用这种方式来擦除变量。
将这个函数限制在shell中是有意义的，因为Erlang经常被用在工业场景中：在这些场景中shell经常持续运行数年。而在这
数年中变量X极有可能被多次使用。
```

原子
==========

变量名不能以小写字母开头是有原因的， 而这个原因就是原子。原子是字面量，它是以其名字为值的常量。
你看到它长什么样，它就是什么样， 除此之外，它什么也不是。原子cat就意味这"cat"，这就是它的全部。
你不能和它玩耍， 不能改变它， 你不能将它打碎； 它就是cat。搞定！

我们可以有很多中方式来使用原子：

```
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated'.
'Atoms can be cheated'
5> atom = 'atom'.
atom
```
如果原子不以小写字母开头或者包含其它非字母字符如（_）, 或@， 则必须用（'）括起来。 
表达式5说明用单引号括起来的原子和不用单引号扩起来的原子是相同的。

我把原子看成是以它们的名字作为值的常量。你以前可能已经使用过常量：作为一个例子，
我们有一些值代表眼睛的颜色：BLUE -> 1, BROWN -> 2, GREEN -> 3, OTHER -> 4. 你
需要将名字映射成底层的数值。原子让你不需要再考虑底层的值： 我们可以将眼睛的颜色
直接定义为 'blue', 'brown', 'green' 以及'other'。这些颜色可以在代码中的任何地方
使用：底层的值永远不会崩溃， 也不会发生这些常量有未定义的时候！ 如果你真的想自己将
常量绑定到它们上面， 我们将会在第四章（模块）中给你介绍这个方法。

因此， 原子通常用来表达或者限制与它耦合在一起的数据。单独使用的话原子没有太大的意义。
这就是为什么我们并没有花费太多的时间来测试的原因； 它和其它类型的数据合起来使用的
时候才显得有意义。

```
不要盲从：
当发送消息或者表示常量的时候， 使用原子是一种很好的方式。但是使用原子来表示大量的事情
也存在着缺点： 原子是存放在一张原子表中的，每个原子都会消耗一定的内存（在32位的系统中
每个原子4个字节， 在64位系统中每个原子8个字节）。原子表不会被垃圾收集，因此原子会不断
地堆积直到系统崩溃， 或者因为用来了内存， 或者因为原子的个数超过了1048577。

这意味着我们不应该动态的生成原子； 如果你的系统需要具备可靠性。 但是用户却可以通过
不断让系统生成原子的方式随意的就可以让它崩溃， 你就会遇到大麻烦了。原子应该做为开发者
的工具， 因为就是为此目的才设计它的。
```

```
注意： 一些原子是保留字：函数名， 操作符， 表达式等， 这些原子有：`after and andalso
band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or 
orelse query receive rem try when xor`。
除了语言设计者赋予它们的意义和使用方式外， 不要用它们来干别的事。
```

布尔代数和比较操作符
====================

一个人如果不能知道大小和真假的话， 他将陷入深深的麻烦。像其它任何语言一样，Erlang也提供
了布尔操作和比较运算。

布尔代数及其简单：

```
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
```

```
注意：布尔操作符 and 和 or 总是计算两边的值。 如果你需要短路操作符（它只会
在需要的时候计算右边的表达式的值），请使用andalso 和 orelse。
```

测试是否相等也是及其简单， 但是Erlang采用了和其它语言不太相同的符号表示：

```
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
```

首先， 不像其它语言使用 == 和 != 来对相等性进行测试， Erlang使用 =:= 和 =/=。最后
3个表达式（9到11行）给我们展现了Erlang的一个缺点：Erlang在做算术运算的时候不会考虑
整型和浮点型的区别， 但是却在比较的时候区别它们。别担心， 如果我们不想在比较的时候
区别对待整型和浮点型， 我们可以用==和/=操作符。遇到这种情况时请记住你是否需要精确的
相等。

其它比较操作符有 <（小于）, >（大于）, >=（大于等于） 和 =<（小于等于）。最后一个
显得有点落后（我的个人意见）， 他是我代码中很多语法错误的根源。请对=<多加小心。

```
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
```

输入 5 + llama 和5 == true 会发生什么？ 没有比将其实际输入然后被错误消息吓得目瞪口呆再好的
方式了！

```
16> 5 + llama.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  +/2
             called as 5 + llama
```
呃！ Erlang不希望你错误地使用它的基本类型！ 模拟器给我们返回了错误消息。
它告诉我们它不喜欢+操作符的两个操作数中的一个！

Erlang并不总是对你给它的错误类型感到发疯：

```
17> 5 =:= true.
false
```
为什么它在一些操作中拒绝不同的类型，但是在另外一些操作中却又允许这样呢？
答案是Erlang虽然不允许任何一个类型都能和所有类型做加法操作，但是它却
允许你对它们进行比较。这是因为Erlang的创造者认为现实胜于理论，它们认为
允许这样的操作可以使得像通用排序算法这样的编码变得简单。它的设计初衷是
让生活变得更简单。

关于布尔代数和比较运算， 我们还需要记住一点：

```
14> 0 == false.
false
15> 1 < false.
true

```
如果你是来自面向过程或者面向对象语言领域的话， 当你看到这样的结果的时候
估计会抓狂。14行看起来应该是true而15行应该是false. 毕竟false意味着0而true
可以是任何东西。但在Erlang中却不是这样的。因为我向你们撒谎了。 是的，请原谅
我吧。

Erlang没有布尔的true和false。true和false事实上是原子，但是它们和语言很好的
集成在一起了， 所以如果你不用true和false来代表其它东西的话，你就不会遇到麻烦。

```
注意： 在比较运算中，正确的大小顺序应该如下：
number < atom > reference < fun < port < pid < tuple < list < bit string

现在你还妹接触到上面所提到的所有类型，但是在阅读完本书之后你将会认识完它们。
现在只需记住这就是为什么你能在任何类型之间进行比较！引用Joe Armstrong的话，
Erlang的创建者之一：“真正的顺序并不重要-但是定义好整体顺序却是重要的。”
```

元组
=======

元组是组织数据的一种方式。它是将数量固定的项式组织在一起的一种方式。在Erlang中，
元组的语法形式为{Element1, Element2, ..., ElementN}。作为一个例子， 假如你给我
一个坐标(x, y)，如果你想告诉我笛卡尔图中一个点的位置。我们可以把这个点表示成两
个项式：

```
1> X = 10, Y = 4.
4
2> Point = {X, Y}.
{10,4}
```
在这种场景中， 一个点总是由两个项式组成。使用元组的方式，我们不用再带着两个项式到处
跑， 我们只需要一个。但是， 如果我收到一个Point变量而我只关心x轴， 这时候该怎么办呢？
这并不是一件很难的事情。让我们开始吧， 开始之前记得使用f() 清除所有的变量。

```
3> Point = {4, 5}.
{4,5}
4> {X, Y} = Point.
{4,5}
5> X.
4
6> {X, _} = Point.
{4,5}
```
从现在开始， 我们可以从X中来拿到元组的第一个元素！但上面的例子是怎么回事呢？起初，X和Y都
没有值， 因此被认为是未绑定变量， 当我们在=操作符左边的元组{X, Y} 里面使用它们的时候, =号
操作符会对两边的值进行比较: {X, Y} vs {4, 5}. Erlang很聪明地将右边元组进行解包并把值分配
给左边的未绑定变量。然后比较就变成了 {4, 5} = {4, 5}， 很明显，这个比较将会成功！ 这是众多
模式匹配中的一种形式。

注意表达式6， 我使用了匿名的_变量。这正是它的使用场景：简单地将值丢弃， 因为我们用不到它。
下划线变量_ 永远是未绑定的，它在模式匹配中被用作通配符。用于元组的模式匹配只有在两边元组
的长度一样时才会成功。

```
8> {_,_} = {4, 5}.
{4,5}
9> {_,_} = {4, 5, 6}.
** exception error: no match of right hand side value {4,5,6}
```
用元组来表示单个值有时候也很有用。最简单的例子就是温度：
```
10> Temprature = 23.213.
23.213
```
好吧， 今天去海滨游玩看起来不错...，等等， 这个温度值的单位是开尔文，摄氏度， 还是是华氏度？

```
11> PreciseTemprature = {celsius, 23.213}.
{celsius,23.213}
12> {kelvin, T} = PreciseTemprature.
** exception error: no match of right hand side value {celsius,23.213}
```
上面的例子抛出了一个错误，但这正是我们所要的！这又是模式匹配在起作用。=操作符最后会比较
{kelvin, T} 和 {celsius, 23.213}：当这个比较发生的时候T还是未绑定的，Erlang发觉原子celsius
和kelvin不能匹配，然后抛出一个异常，后续的代码将得不到执行。通过这种方式， 如果我们的代码期望
的是以Kelvin为单位的温度值，那它将永远不能处理以Celsius为单位的温度值。这样程序员很容易知道
代码之间发送的消息， 这可以辅助调试。以原子开头随后跟着一个元素的元组被称为‘带标签的元组’，
元组里面的元素可以是任何类型，也可以是另一个元组。

```
12> {point, {X, Y}}.
{point,{4,5}}

```
如果我们想存储多个点怎么办？

列表！
==================
列表是很多函数式语言吃饭的家伙。它们被用来解决几乎所有的问题，毫无疑问， 它在Erlang中也是最常用的数据结构。列表可以包含任何东西！
数字， 原子， 元组，其它列表； 它让你用一个数据结构表示所有东西的梦想变得触手可及。列表基本的记法为：[Element1, Element2, ..., ElementN]，你
可以在其中混合存放不同类型的数据：

```
1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
```
很简单对吧？

```
2> [97, 98, 99].
"abc"
```
啊， 不！ 这是Erlang最让人讨厌的地方：字符串！字符串就是列表，它们的记法完全一样！人们为什么不喜欢它呢？请看下面的例子：

```
3> [97, 98, 99, 4, 5, 6]. 
[97,98,99,4,5,6]
4> [233].
"é"
```
Erlang只有在至少有一个元素不能表示成字母的时候才将列表以数字的形式打印出来！Erlang中没有真正的字符串！ 这个问题会在将来一直困扰着你，
而你很有可能因此而憎恨这门语言。不要绝望，因为我们有其它的方式来书写字符串， 我们将会在本章的后续小节介绍这点。

```
不要盲从

这就是你所听到的Erlang在字符串操作上烂透了：它不像其它语言那样有内置的字符串类型。这是因为Erlang最初是为电信公司设计的一门语言。
它们从来不用或者很少使用字符串，所以官方没有考虑过将其加入到语言中。但是，Erlang在字符串处理上的不足正逐步得到改善：
现在虚拟机已经支持Unicode字符串，并且字符串操作正变得越来越快。

我们还可以将字符串以二进制数据结构的形式存储，这让它非常轻量级和高效。总之，标准库里面还是缺少一些和字符串相关的东西，如果你需要
大量的字符串操作， 使用Perl或者Python会更好些。
```
我们使用++来连接列表。与之相反的是我们使用--来将元素从列表中移除：

```
5> [1, 2, 3] ++ [4, 5].
[1,2,3,4,5]
6> [1, 2, 3, 4, 5] -- [1, 2, 3].
[4,5]
7> [2,4,2] -- [2, 4].
[2]
8> [2, 4, 2] -- [2, 4, 2].
[]
```

++ 和 -- 都是右关联的。 这意味着当多个++和--在一起的时候， 计算顺序是从右到左的。就像下面的例子：

```
9> [1, 2, 3] -- [1, 2] -- [3].
[3]
10> [1, 2, 3] -- [1, 2] -- [2].
[2,3]
```
让我们继续。列表的第一元素被称为头（译注：棒打出头鸟，每次受伤的都是它），剩下的被称为尾。我们使用两个内置函数来获取它。

```
11> hd([1, 2, 3, 4]).
1
12> tl([1, 2, 3, 4]).
[2,3,4]
```

```
注意：内置函数通常是那些不能用纯Erlang来实现的函数，因此它们是用C或者Erlang的实现语言(80年代的时候是Prolog)来定义的， 
有些函数可以用纯粹的Erlang来实现但是它们仍然使用了C， 以此来获得更高的速度。其中一个例子就是length(List)函数，它会返回
传入list的长度。
```
访问和添加头元素非常快速而高效：当操作列表的时候我们总是首先处理头元素(译注：出头鸟啊。。。)，因为它被如此广泛地使用，Erlang以模式匹配的
方式提供了更为优雅的访问头元素的方法：[Head|Tail]。你可以通过以下方式给列表增加一个头元素:

```
13> List = [2, 3, 4].
[2,3,4]
14> NewList = [1 | List].
[1,2,3,4]
```
当处理列表的时候， 因为总是从头元素开始，所以你需要一种快捷的方式将列表尾存储起来以备后续访问。 如果你记得元组是怎么工作的以及我们怎么
使用模式匹配解包元组point（{X, Y}）的值的话。你就会猜到我们可以使用类似的方式来获取列表的第一个元素（列表头）。

```
15> [Head|Tail] = NewList.
[1,2,3,4]
16> Head.
1
17> Tail.
[2,3,4]
18> [NewHead|NewTail] = Tail.
[2,3,4]
19> NewHead.
2
```
我们使用竖线来表示cons操作符(构造器). 事实上， 任何列表都可以只用cons和值来构造:
```
20> [1 | []].
[1]
21> [2 | [1 | []]].
[2,1]
22> [3 | [2 | [1 | []]]].
[3,2,1]
```
就是说任何列表都可以使用这个公式来构造:[Term1 | [Term2 | [... | [TermN]]]]...。
这样列表就可以使用头加上尾进行递归定义。从这个角度考虑， 我们可以将列表想象
成一条蚯蚓：从中间把它从中间砍断， 你将会得到2条蚯蚓。

对于不熟悉构造器的读者来说， 很容易对Erlang构造列表的方式感到困惑。为了帮助理解这个概念， 请阅读下面的
例子（提示：它们都是等价的）：
```
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
```
理解了上面这些例子， 你就能够搞定列表推导了。

```
注： [1 | 2] 这样的形式定义了一个“非良构”的列表。在非良构列表上可以使用形如[Head|Tail]这样的模式匹配操作， 
当时不能使用Erlang标准库的函数对它们进行处理， 甚至length()也不行。因为Erlang期望列表都是良构的。良构的列表
都以一个空列表结尾。当我们声明列表 [2]时，它会被自动转化为良构列表。因此, [1 | [2]]是良构的！ 非良构列表尽管
在语法上是正确的， 但它的应用场景在用户自定义的数据结构外却非常罕见。
```
列表推导
==========

列表推到是构建和修改列表的一种方式。和其它列表操作相比它也让程序变得更短和更易于理解。
它基于集合表示法；如果你上过数学课上的集合理论知道数学表示法，你就很容易知道它们是怎
么工作的。集合表示法通过指明集合元素必须满足的属性来表示一个集合。刚开始可能很难理解
列表推导， 但是它是一件值得我们付出努力的事。因为它让代码变得更干净简短，所以，不要犹豫！
请亲自尝试下面的例子直到你理解它们！

集合表示法的一个例子是{χ ∈ R:  χ = χ²}.. 这个记法表示的集合为所有等于它们自己平方数的实数。
其结果是 {0, 1}。让我们再举一个更简单的例子， `{x: x > 0}`。在这个例子里，我们想要的结果是
所有x > 0 的实数。

Erlang中的列表推导指的是从已有的集合中构造出新的集合。给定集合 {2n : n in L}。这里L = [1, 2, 3, 4]，
在Erlang中采用如下的方式表述：

```
1> [2*N || N <- [1, 2, 3, 4]].
[2,4,6,8]
```

将Erlang的表示法和数学表示法相比并没有太大的不同：花括号({})变成了方括号([])，
冒号(:)变成了两条竖线(||)，单词 'in' 变成了向左的箭头(<-)。我们改变了符号的表示
方法， 但是保留了其逻辑意义。上面的例子中， [1, 2, 3, 4]中的每个值都会被按顺序的
和N进行模式匹配， 这里箭头的作用和等号的作用是一样的，但是它不会抛异常。

你可以通过使用返回布尔值的操作来给列表推导添加限制条件。如果想得到从1到10中的所有偶数， 我们可以如下做：

```
2> [X || X <- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], X rem 2 =:= 0].
[2,4,6,8,10]
```
在这里 X rem 2 =:= 0 检查一个数是否是偶数。当我们想对列表的每个元素应用一个
函数（译注：以列表的单个元素为参数调用函数），强制这些元素
遵从我们的限制条件的时候， 这就显得很有用了。例如，假设我有一个餐馆。一个客户
走进来，查看我们的菜单并询问我们价钱从$3到$10并且税率为7%的菜。

```
3> RestaurantMenu = [{steak, 5.99}, {beer, 3.99}, {poutine, 3.50}, {kitten, 20.99}, {water, 0.00}].
[{steak,5.99},
{beer,3.99},
{poutine,3.5},
{kitten,20.99},
{water,0.0}]
4> [{Item, Price*1.07} || {Item, Price} <- RestaurantMenu, Price >= 3, Price =< 10].
[{steak,6.409300000000001},{beer,4.2693},{poutine,3.745}]
```
上面的数字没有四舍五入为可读的形式， 可是我想你已经把关键的点抓住了。Erlang中列表推导的表达方式为：
`NewList = [Expression || Pattern <- List, Condition1, Condition2, ..., ConditionN]`。
其中的`Pattern <- List` 被称为产生器表达式， 可以使用多个产生器表达式。

```
5> [X+Y || X <- [1, 2], Y <- [2, 3]].
[3,4,4,5]
```
上面的例子将会执行1+2， 1+3， 2+2， 2+3。所以， 列表推导更通用表达形式为：
`NewList = [Expression || GeneratorExp1, GeneratorExp2, ..., GeneratorExpN, Condition1, Condition2, ... ConditionM]`
注意在这里产生器表达式和模式匹配合起来也可以作为过滤器。

```
6> Weather = [{toronto, rain}, {montreal, storms}, {london, fog},  
6>            {paris, sun}, {boston, fog}, {vancouver, snow}].
[{toronto,rain},
{montreal,storms},
{london,fog},
{paris,sun},
{boston,fog},
{vancouver,snow}]
7> FoggyPlaces = [X || {X, fog} <- Weather].
[london,boston]
```
如果列表Weather中的元组不能和{X, fog}匹配，它会被简单的忽略，就这一点上他和=操作符有所不同，
=号操作符遇到不匹配的时候会抛出异常。

我们只剩下最后一种数据类型了。这是一个足以让人感到惊奇的特性， 它使得解析二进制数据变得易如反掌。

位语法！
========
大部分的语言都支持操作数字，原子，元组，列表， 和结构体这样的数据。它们中的大部分也有
低级的支持工具来处理数据。Erlang在这方面优于其它语言，它使用模式匹配提供了很好的抽象来
处理二进制值。 这使得处理原始的二进制数据变得很有趣和简单(真的！)。这对电信应用来说
是很有必要的。位操作有其独特的语法， 它的习惯用法初次看起来会觉得很怪异，但是一旦
掌握了位和字节的的工作原理， 你就会觉得这很合理。你也可以略过本章的后续部分。

位语法使用<<和>>将数据括起来，把数组分成具有可读性的片段，用逗号分割不同的片段（这在
字节边界上不是必须的，但这是默认的行为)。假设我想存储一个真彩色(24 bits)的橙色的点。如
过你在Photoshop和CSS中使用过颜色，你就知道它们是用16进制来表示的， 形如#RRGGBB，使用这种表示法，
浅橙色被表示为#F09A29，在Erlang中， 我们这样表示它：

```
1> Color = 16#F09A29.
15768105
2> Pixel = <<Color:24>>.
<<240,154,41>>
```
上面的例子意思是 “将#F09A29 的二进制值放到Pixel变量所代表的24位的空间里面（红8位，绿8位，蓝8位）”
我们后续可以将这个值存储到文件中，如果你用文本编辑器将其打开， 看到的僵尸一堆无法阅读的字符。
当将它们从文件中读取回内存时，Erlang又将它们解释成<<240, 151, 41>>这样的格式！

更有趣的事是我们可以用模式匹配来对二进制的内容进行解包处理：

```
3> Pixels = <<213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
4> <<Pix1, Pix2, Pix3, Pix4>> = Pixels.
** exception error: no match of right hand side value <<213,45,132,64,76,32,76,0,0,234,32,15>>
5> <<Pix1:24, Pix2:24, Pix3:24, Pix4:24>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
```
我们在命令3中使用二进制的形式声明了RGB颜色的四个点。在第四个表达式中，我们试图
从该二进制中解包出4个值。但是它抛出了一个异常，因为我们有多余4个的二进制段。事
实上我们有12个段那么多！ 所以我们得告诉Erlang，左边的每个变量都要存储24位的数据。
这就是Var:24的目的。我们可以进一步将第一个点解包成单个颜色值：

```
6> <<R:8, G:8, B:8>> = <<Pix1:24>>.
<<213,45,132>>
7> R.
213
```
“真是极品的东西啊。如果我一开始就只想要第一个颜色该怎么办？ 难道我每次都需要
解包所有的值吗？“ 哈哈， 肯定不是啦！ Erlang引入了额外的语法糖来帮助我们处理
这个问题：

```
8> <<R:8, Rest/binary>> = Pixels.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
9> R.
213
```
很棒， 不是吗？ 那是因为对于一个二进制段， Erlang有多种方式来表示它。以下这些
都是合法的：

	Value
	Value:Size
	Value:TypeSpecifierList
	Value:Size/TypeSpecifierList
	Size表示位或字节的长度（这取决于Type和Unit）， 而TypeSpecifierList则可以取以下的值：
	Type
	可取值：integer | float | binary | bytes | bitstring | bits | utf8 | utf16 | utf32
	这些值代表我们使用的二进制数据的类型。bytes是binary的缩写， 而bits是bitstring的缩写。
	当我们没有明确的给出类型的时候， 默认为integer类型。

	Signedness
	可取值：signed | unsigned
	只有类型是整型的时候才有效。默认是'unsigned'

	Endianness
	可取值：bit | little | native
	大小端模式只在Type是integer，utf16, utf32,或者float的时候才有效。这关系到系统怎么读取二进制数据。
	例如：BMP图像的头部使用一个4字节的整数来表示整个文件的大小。对于一个有72个字节的文件，小端系统会
	将其表示为<<72, 0, 0, 0>>而大端则将其表示为<<0, 0, 0, 72>>。其中一个表示的整型值为‘72’而另一个表
	示的整型值为'1207959552'，所以，请确保你使用了正确的大小端。'native'选项则在运行时根据CPU来选择
	大小端。默认的大小端采用的是‘大端模式’。

	Unit
	书写方式为: unit:Integer
	它指明段的单位占多少个位（）。允许的范围为1...256，integer，float和bitstring默认的值为1，binary的
	默认值为8.utf8，utf16，utf32不需要定义这个字段。将Unit 和 Size相乘的结果就是一个二进制段所占有的bit的个数,
	这个结果必须能被8整除， 单位的大小通常用来保证字节对齐。

	类型修饰符列表（TypeSpecifierList）之间使用一个'-'进行分隔。

	让我们以一些例子来对定义进行消化：
	
```
10> <<X1/unsigned>> = <<-44>>.
<<"Ô">>
11> X1.
212
12> <<X2/signed>> = <<-44>>.
<<"Ô">>
13> X2.
-44
14> <<X2/integer-signed-little>> = <<-44>>.
<<"Ô">>
15> X2.
-44
16> <<N:8/unit:1>> = <<72>>.
<<"H">>
17> N.
72
18> <<N/integer>> = <<72>>.
<<"H">>
19> <<Y:4/little-unit:8>> = <<72, 0, 0, 0>>.
<<72,0,0,0>>
20> Y.
72
```
我们可以看到对于二进制数据， 我们有多种方式读取，存储和解释它。这让人有点困惑，但是相比其它大多数
语言， 这也已经很简单了。

Erlang也有标准的二进制操作(把位从左移动到右，从右移到左，二进制'and'， 'xor', 或者 ‘not’)。
对应的操作符为 bsl(位左移)，bsr(位右移动)， band, bor, bxor和bnot。

```
2#00100 = 2#00010 bsl 1.
2#00001 = 2#00010 bsr 1.
2#10101 = 2#10001 bor 2#00101.
```
有了各种表示法和位语法，解析和对二进制进行模式匹配就成了小菜一碟。我们可以使用如下的代码
来解包TCP包：

```
<<SourcePort:16, DestinationPort:16,
AckNumber:32,
DataOffset:4, _Reserved:4, Flags:8, WindowSize:16,
CheckSum: 16, UrgentPointer:16,
Payload/binary>> = SomeBinary.
```
相同的逻辑可以应用到视频编码， 处理图像，其它协议的实现等等等等。

```
不要盲从
虽然我在前面展示了它那有趣的二进制语法，Erlang和很多类似C, C++这样的语言相比会比较慢。除非你是一个很有耐心的人，
否则使用Erlang来对视频或者图像进行转换将会是一件让人痛苦的事a Erlang在需要重度数字处理的领域表现得不怎么样。

但是，Erlang在那些不需要重度数字处理的领域还是相当快的：事件响应，消息传递(得益于非常轻量级的原子)等，它可以在
几个毫秒内对事件做出响应，因此非常适合软实时应用。
```

关于二进制表示法， 我们还需要再提一点：bit strings。在语言的层面二进制字符串和列表都使用相同的方式构造。
但是它们比列表在空间利用率上更高效。这是因为普通的列表是由链表组成的（每个字母都要占一个字节）而位串更
像C语言的数组。位串的语法表示为<<"this is a bit string">>。二进制字符串的一个缺点为它在模式匹配上比不上
列表那么简单。所以，人们倾向于使用二进制字符串来存储那些不需要太多后续操作的文本，或者当空间利用率变成
不得不考虑的因素时选择它。

```
注意： 虽然位串非常轻量级，我们也不应该将它作为其它值的标签。我们很可能会出现这样的
用法{<<"temperature", 50>>}， 这种时候我们更应该使用原子来表示。这一章的前部分我们已经
说过原子不管它有多长，都只占用4个到8个字节。当我门在函数间拷贝数据或者将数据发送到其它
Erlang节点的时候， 使用原子无疑代价是最小的。反之， 我们也不应该因为原子非常轻量就使用它
来代替字符串。我们可以对字符串进行各种操作(分割， 正则表达式，等等)， 但是对于原子， 
我们却只能进行比较， 除此之外， 啥也干不了。
```

二进制推导
================

二进制推导和列表推导类似：它是一种让代码更简洁和精确的方法。它们是在上一个修订版才加入的， 因此相当新。
它已经称为标准， 所以可以在任何地方使用它， 包括shell：

```
1> [X || <<X>> <= <<1, 2, 3, 4, 5>>, X rem 2 == 0].
[2,4]
```
它和列表推导的不同仅在于(<-)变成了(<=)， 以及([]) 变成了 (<<>>)。在这章的前面，我们使用模式匹配
来从一个颜色点中获取RGB值。这虽然可行， 但是如果把这种方法来用到大的数据结构中， 将会变得难以阅读
和维护。我们可以使用二进制推导来完成这个任务，这看起来更简洁：

```
2> Pixels = <<213,45,132,64,76,32,76,0,0,234,32,15>>.
<<213,45,132,64,76,32,76,0,0,234,32,15>>
3> RGB = [ {R,G,B} || <<R:8,G:8,B:8>> <= Pixels  ].
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
```
将<-换成<=让我们可以将二进制流作为产生器。上面这个例子将二进制数据转换成整型数据，我们也可以
将整型转成二进制数据：

```
<< <<R:8, G:8, B:8>> ||  {R,G,B} <- RGB >>
<<213,45,132,64,76,32,76,0,0,234,32,15>>
```
请小心， 当产生器返回的是二进制数据的时候， 结果元素需要明确指明长度。

```
5> << <<Bin>> || Bin <- [<<3,7,5,4,7>>] >>.
** exception error: bad argument
6> << <<Bin/binary>> || Bin <- [<<3,7,5,4,7>>] >>. 
<<3,7,5,4,7>>
```
我们也可以使用二进制产生器， 上面那个需要给出长度的例子可以使用下面的记法：

```
7> << <<(X+1)/integer>> || <<X>> <= <<3,7,5,4,7>> >>.
<<4,8,6,5,8>>
```

```
注意： 书写本书的时候， 二进制构造还很少被使用， 而且文档也没有很好的描述它。 因此，我们这里只是为了完整性考虑而介绍
它最基本的部分以理解它的工作原理。如果想完整地理解位语法，请阅读[关于位语法的白皮书](http://user.it.uu.se/~pergu/papers/erlang05.pdf) ```



































































































































































































































































































































































































































































