真正的开始
================
<font color="#D1E9E9">
```
Erlang是一门相对小而且简单的语言（就像C之于C++）。语言里面只内置了一些基本的数据类型，
因此，本章就能覆盖其中的大部分。强烈建议阅读本章， 因为它解释了语言的基本构造块，今后
使用Erlang写程序就仰赖它们了。
```
</font>

数字
------------

在Erlang shell中，**表达式必须以(.)后跟一个空白符（换行，空格等）结束，否则的话它们不会被执行**，你可以使用(,)来分割表达式
但是只有最后一个表达式的结果会被显示（其它的表达式仍然被执行了）。这对大多数人来说都不是一种常见的语法。这种语法形式是由于
Erlang早期是用Prolog来实现的，Prolog是一门逻辑编程语言。

使用上一章的方法打开Erlang shell，让我们输入一些东西瞧瞧！

```
Erlang/OTP 17 [erts-6.4.1.5] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.4.1.5  (abort with ^G)
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472
3> .
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
```
你可能已经注意到Erlang不在意你是输入了浮点数还是整数：在算术运算中两种类型都是被支持的。整型和浮点型是唯一的
两种Erlang的数学操作符号，Erlang会为我们透明地处理这两种类型。但是， 请使用div来作整除，使用rem来做求余运算。

我们可以在单个表达式中使用多个操作符，数学运算符之间遵守正常的优先级规则。

```
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
```

如果你想表达10进制以外的整数，请输入Base#Value(基数的范围在2..36)

```
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
```
太棒了！ Erlang有着和你桌子边角上那个有着怪异语法的计算器同样的能力。
这太让人激动了！

变量不可变
=========

做运算我们已经没有问题了， 但是如果我们不能将运算结果保存起来，这意义也不大。
为此，我们将使用变量。如果你阅读了本书的介绍部分，则你已经知道了变量在函数式
编程中是不可变的。变量的基本行为可以用这7个表达式来演示（请注意变量以大写字母开头）：

```
1> One.
1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
```

这些命令给我们的第一点提示是你只能给变量赋值一次；然后你可以假装给一个变量赋值，但是值
要和它已有的值相同。如果它不同， Erlang将会抱怨。我们正确地观察到了这点，但是解释它是一件
相当复杂的事， 因为它依赖于=操作符。=操作符（指的不是变量）负责比较两个值，如果两边的值不等，
它将向我们发出抱怨。如果两边的值相等，它就把这个值返回:

```
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
```

=操作符和变量合在一起使用所表达的意思是如果变量是未绑定的（没有值和它关联），Erlang会自动将右边的值
绑定到左边的变量上。因此后续的比较会成功，变量在内存中持有该值。

=号操作符的这种行为是“模式匹配”的基础， 很多的函数式编程语言里面都有模式匹配，但是这在Erlang里面更加
灵活和完整。我们在本章元组和列表的部分和后续章节的函数部分再详细谈论这点。

这7个命令给我们的一个另外的提示是变量必须以大写字母开头. 第7个命令因为two是以小写字母开头的而失败了。
从技术上将， 变量也可以以('_')，开头，它用来表示那些我们不关心其值， 但为了完整性考虑，我们仍然将它写出来。

你可以只用一个下划线来表示变量：

```
10> _ = 14 + 3.
17
11> _.
* 1: variable '_' is unbound
```

不像其它类型的变量，它不会存储任何的值。现在它对我们来说没有任何用处，但是当我们需要它的时候， 你就应该知道
有这么一个东西

```
注意： 如果你在shell里面作测试的时候把错误的值赋给了变量， 可以使用函数f(Variable).来擦除变量。使用f().来擦除
左右的变量。

这个函数只在你作测试的时候使用， 它只能在shell中使用。当编写真正的程序的时候，我们不能使用这种方式来擦除变量。
将这个函数限制在shell中是有意义的，因为Erlang经常被用在工业场景中：在这些场景中shell经常持续运行数年。而在这
数年中变量X极有可能被多次使用。
```

原子
==========

变量名不能以小写字母开头是有原因的， 而这个原因就是原子。原子是字面量，它是以其名字为值的常量。
你看到它长什么样，它就是什么样， 除此之外，它什么也不是。原子cat就意味这"cat"，这就是它的全部。
你不能和它玩耍， 不能改变它， 你不能将它打碎； 它就是cat。搞定！

我们可以有很多中方式来使用原子：

```
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated'.
'Atoms can be cheated'
5> atom = 'atom'.
atom
```
如果原子不以小写字母开头或者包含其它非字母字符如（_）, 或@， 则必须用（'）括起来。 
表达式5说明用单引号括起来的原子和不用单引号扩起来的原子是相同的。

我把原子看成是以它们的名字作为值的常量。你以前可能已经使用过常量：作为一个例子，
我们有一些值代表眼睛的颜色：BLUE -> 1, BROWN -> 2, GREEN -> 3, OTHER -> 4. 你
需要将名字映射成底层的数值。原子让你不需要再考虑底层的值： 我们可以将眼睛的颜色
直接定义为 'blue', 'brown', 'green' 以及'other'。这些颜色可以在代码中的任何地方
使用：底层的值永远不会崩溃， 也不会发生这些常量有未定义的时候！ 如果你真的想自己将
常量绑定到它们上面， 我们将会在第四章（模块）中给你介绍这个方法。

因此， 原子通常用来表达或者限制与它耦合在一起的数据。单独使用的话原子没有太大的意义。
这就是为什么我们并没有花费太多的时间来测试的原因； 它和其它类型的数据合起来使用的
时候才显得有意义。

```
不要盲从：
当发送消息或者表示常量的时候， 使用原子是一种很好的方式。但是使用原子来表示大量的事情
也存在着缺点： 原子是存放在一张原子表中的，每个原子都会消耗一定的内存（在32位的系统中
每个原子4个字节， 在64位系统中每个原子8个字节）。原子表不会被垃圾收集，因此原子会不断
地堆积直到系统崩溃， 或者因为用来了内存， 或者因为原子的个数超过了1048577。

这意味着我们不应该动态的生成原子； 如果你的系统需要具备可靠性。 但是用户却可以通过
不断让系统生成原子的方式随意的就可以让它崩溃， 你就会遇到大麻烦了。原子应该做为开发者
的工具， 因为就是为此目的才设计它的。
```

```
注意： 一些原子是保留字：函数名， 操作符， 表达式等， 这些原子有：`after and andalso
band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or 
orelse query receive rem try when xor`。
除了语言设计者赋予它们的意义和使用方式外， 不要用它们来干别的事。
```

布尔代数和比较操作符
====================

一个人如果不能知道大小和真假的话， 他将陷入深深的麻烦。像其它任何语言一样，Erlang也提供
了布尔操作和比较运算。

布尔代数及其简单：

```
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
```

```
注意：布尔操作符 and 和 or 总是计算两边的值。 如果你需要短路操作符（它只会
在需要的时候计算右边的表达式的值），请使用andalso 和 orelse。
```

测试是否相等也是及其简单， 但是Erlang采用了和其它语言不太相同的符号表示：

```
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
```

首先， 不像其它语言使用 == 和 != 来对相等性进行测试， Erlang使用 =:= 和 =/=。最后
3个表达式（9到11行）给我们展现了Erlang的一个缺点：Erlang在做算术运算的时候不会考虑
整型和浮点型的区别， 但是却在比较的时候区别它们。别担心， 如果我们不想在比较的时候
区别对待整型和浮点型， 我们可以用==和/=操作符。遇到这种情况时请记住你是否需要精确的
相等。

其它比较操作符有 <（小于）, >（大于）, >=（大于等于） 和 =<（小于等于）。最后一个
显得有点落后（我的个人意见）， 他是我代码中很多语法错误的根源。请对=<多加小心。

```
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
```

输入 5 + llama 和5 == true 会发生什么？ 没有比将其实际输入然后被错误消息吓得目瞪口呆再好的
方式了！

```
16> 5 + llama.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  +/2
             called as 5 + llama
```

















