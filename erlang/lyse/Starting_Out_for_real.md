真正的开始
================
<font color="#D1E9E9">
```
Erlang是一门相对小而且简单的语言（就像C之于C++）。语言里面只内置了一些基本的数据类型，
因此，本章就能覆盖其中的大部分。强烈建议阅读本章， 因为它解释了语言的基本构造块，今后
使用Erlang写程序就仰赖它们了。
```
</font>

数字
------------

在Erlang shell中，**表达式必须以(.)后跟一个空白符（换行，空格等）结束，否则的话它们不会被执行**，你可以使用(,)来分割表达式
但是只有最后一个表达式的结果会被显示（其它的表达式仍然被执行了）。这对大多数人来说都不是一种常见的语法。这种语法形式是由于
Erlang早期是用Prolog来实现的，Prolog是一门逻辑编程语言。

使用上一章的方法打开Erlang shell，让我们输入一些东西瞧瞧！

```
Erlang/OTP 17 [erts-6.4.1.5] [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]

Eshell V6.4.1.5  (abort with ^G)
1> 2 + 15.
17
2> 49 * 100.
4900
3> 1892 - 1472
3> .
420
4> 5 / 2.
2.5
5> 5 div 2.
2
6> 5 rem 2.
1
```
你可能已经注意到Erlang不在意你是输入了浮点数还是整数：在算术运算中两种类型都是被支持的。整型和浮点型是唯一的
两种Erlang的数学操作对象，Erlang会为我们透明地处理这两种类型。但是， 请使用div来作整除，使用rem来做求余运算。

我们可以在单个表达式中使用多个操作符，数学运算符之间遵守正常的优先级规则。

```
7> (50 * 100) - 4999.
1
8> -(50 * 100 - 4999).
-1
9> -50 * (100 - 4999).
244950
```

如果你想表达10进制以外的整数，请输入Base#Value(基数的范围在2..36)

```
10> 2#101010.
42
11> 8#0677.
447
12> 16#AE.
174
```
太棒了！ Erlang有着和你桌子边角上那个有着怪异语法的计算器同样的能力。
这太让人激动了！

变量不可变
=========

做运算我们已经没有问题了， 但是如果我们不能将运算结果保存起来，这意义也不大。
为此，我们将使用变量。如果你阅读了本书的介绍部分，则你已经知道了变量在函数式
编程中是不可变的。变量的基本行为可以用这7个表达式来演示（请注意变量以大写字母开头）：

```
1> One.
1: variable 'One' is unbound
2> One = 1.
1
3> Un = Uno = One = 1.
1
4> Two = One + One.
2
5> Two = 2.
2
6> Two = Two + 1.
** exception error: no match of right hand side value 3
7> two = 2.
** exception error: no match of right hand side value 2
```

这些命令给我们的第一点提示是你只能给变量赋值一次；然后你可以假装给一个变量赋值，但是值
要和它已有的值相同。如果它不同， Erlang将会抱怨。我们正确地观察到了这点，但是解释它是一件
相当复杂的事， 因为它依赖于=操作符。=操作符（指的不是变量）负责比较两个值，如果两边的值不等，
它将向我们发出抱怨。如果两边的值相等，它就把这个值返回:

```
8> 47 = 45 + 2.
47
9> 47 = 45 + 3.
** exception error: no match of right hand side value 48
```

=操作符和变量合在一起使用所表达的意思是如果变量是未绑定的（没有值和它关联），Erlang会自动将右边的值
绑定到左边的变量上。因此后续的比较会成功，变量在内存中持有该值。

=号操作符的这种行为是“模式匹配”的基础， 很多的函数式编程语言里面都有模式匹配，但是这在Erlang里面更加
灵活和完整。我们在本章元组和列表的部分和后续章节的函数部分再详细谈论这点。

这7个命令给我们的一个另外的提示是变量必须以大写字母开头. 第7个命令因为two是以小写字母开头的而失败了。
从技术上将， 变量也可以以('_')，开头，它用来表示那些我们不关心其值， 但为了完整性考虑，我们仍然将它写出来。

你可以只用一个下划线来表示变量：

```
10> _ = 14 + 3.
17
11> _.
* 1: variable '_' is unbound
```

不像其它类型的变量，它不会存储任何的值。现在它对我们来说没有任何用处，但是当我们需要它的时候， 你就应该知道
有这么一个东西

```
注意： 如果你在shell里面作测试的时候把错误的值赋给了变量， 可以使用函数f(Variable).来擦除变量。使用f().来擦除
左右的变量。

这个函数只在你作测试的时候使用， 它只能在shell中使用。当编写真正的程序的时候，我们不能使用这种方式来擦除变量。
将这个函数限制在shell中是有意义的，因为Erlang经常被用在工业场景中：在这些场景中shell经常持续运行数年。而在这
数年中变量X极有可能被多次使用。
```

原子
==========

变量名不能以小写字母开头是有原因的， 而这个原因就是原子。原子是字面量，它是以其名字为值的常量。
你看到它长什么样，它就是什么样， 除此之外，它什么也不是。原子cat就意味这"cat"，这就是它的全部。
你不能和它玩耍， 不能改变它， 你不能将它打碎； 它就是cat。搞定！

我们可以有很多中方式来使用原子：

```
1> atom.
atom
2> atoms_rule.
atoms_rule
3> atoms_rule@erlang.
atoms_rule@erlang
4> 'Atoms can be cheated'.
'Atoms can be cheated'
5> atom = 'atom'.
atom
```
如果原子不以小写字母开头或者包含其它非字母字符如（_）, 或@， 则必须用（'）括起来。 
表达式5说明用单引号括起来的原子和不用单引号扩起来的原子是相同的。

我把原子看成是以它们的名字作为值的常量。你以前可能已经使用过常量：作为一个例子，
我们有一些值代表眼睛的颜色：BLUE -> 1, BROWN -> 2, GREEN -> 3, OTHER -> 4. 你
需要将名字映射成底层的数值。原子让你不需要再考虑底层的值： 我们可以将眼睛的颜色
直接定义为 'blue', 'brown', 'green' 以及'other'。这些颜色可以在代码中的任何地方
使用：底层的值永远不会崩溃， 也不会发生这些常量有未定义的时候！ 如果你真的想自己将
常量绑定到它们上面， 我们将会在第四章（模块）中给你介绍这个方法。

因此， 原子通常用来表达或者限制与它耦合在一起的数据。单独使用的话原子没有太大的意义。
这就是为什么我们并没有花费太多的时间来测试的原因； 它和其它类型的数据合起来使用的
时候才显得有意义。

```
不要盲从：
当发送消息或者表示常量的时候， 使用原子是一种很好的方式。但是使用原子来表示大量的事情
也存在着缺点： 原子是存放在一张原子表中的，每个原子都会消耗一定的内存（在32位的系统中
每个原子4个字节， 在64位系统中每个原子8个字节）。原子表不会被垃圾收集，因此原子会不断
地堆积直到系统崩溃， 或者因为用来了内存， 或者因为原子的个数超过了1048577。

这意味着我们不应该动态的生成原子； 如果你的系统需要具备可靠性。 但是用户却可以通过
不断让系统生成原子的方式随意的就可以让它崩溃， 你就会遇到大麻烦了。原子应该做为开发者
的工具， 因为就是为此目的才设计它的。
```

```
注意： 一些原子是保留字：函数名， 操作符， 表达式等， 这些原子有：`after and andalso
band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or 
orelse query receive rem try when xor`。
除了语言设计者赋予它们的意义和使用方式外， 不要用它们来干别的事。
```

布尔代数和比较操作符
====================

一个人如果不能知道大小和真假的话， 他将陷入深深的麻烦。像其它任何语言一样，Erlang也提供
了布尔操作和比较运算。

布尔代数及其简单：

```
1> true and false.
false
2> false or true.
true
3> true xor false.
true
4> not false.
true
5> not (true and true).
false
```

```
注意：布尔操作符 and 和 or 总是计算两边的值。 如果你需要短路操作符（它只会
在需要的时候计算右边的表达式的值），请使用andalso 和 orelse。
```

测试是否相等也是及其简单， 但是Erlang采用了和其它语言不太相同的符号表示：

```
6> 5 =:= 5.
true
7> 1 =:= 0.
false
8> 1 =/= 0.
true
9> 5 =:= 5.0.
false
10> 5 == 5.0.
true
11> 5 /= 5.0.
false
```

首先， 不像其它语言使用 == 和 != 来对相等性进行测试， Erlang使用 =:= 和 =/=。最后
3个表达式（9到11行）给我们展现了Erlang的一个缺点：Erlang在做算术运算的时候不会考虑
整型和浮点型的区别， 但是却在比较的时候区别它们。别担心， 如果我们不想在比较的时候
区别对待整型和浮点型， 我们可以用==和/=操作符。遇到这种情况时请记住你是否需要精确的
相等。

其它比较操作符有 <（小于）, >（大于）, >=（大于等于） 和 =<（小于等于）。最后一个
显得有点落后（我的个人意见）， 他是我代码中很多语法错误的根源。请对=<多加小心。

```
12> 1 < 2.
true
13> 1 < 1.
false
14> 1 >= 1.
true
15> 1 =< 1.
true
```

输入 5 + llama 和5 == true 会发生什么？ 没有比将其实际输入然后被错误消息吓得目瞪口呆再好的
方式了！

```
16> 5 + llama.
** exception error: an error occurred when evaluating an arithmetic expression
     in operator  +/2
             called as 5 + llama
```
呃！ Erlang不希望你错误地使用它的基本类型！ 模拟器给我们返回了错误消息。
它告诉我们它不喜欢+操作符的两个操作数中的一个！

Erlang并不总是对你给它的错误类型感到发疯：

```
17> 5 =:= true.
false
```
为什么它在一些操作中拒绝不同的类型，但是在另外一些操作中却又允许这样呢？
答案是Erlang虽然不允许任何一个类型都能和所有类型做加法操作，但是它却
允许你对它们进行比较。这是因为Erlang的创造者认为现实胜于理论，它们认为
允许这样的操作可以使得像通用排序算法这样的编码变得简单。它的设计初衷是
让生活变得更简单。

关于布尔代数和比较运算， 我们还需要记住一点：

```
14> 0 == false.
false
15> 1 < false.
true

```
如果你是来自面向过程或者面向对象语言领域的话， 当你看到这样的结果的时候
估计会抓狂。14行看起来应该是true而15行应该是false. 毕竟false意味着0而true
可以是任何东西。但在Erlang中却不是这样的。因为我向你们撒谎了。 是的，请原谅
我吧。

Erlang没有布尔的true和false。true和false事实上是原子，但是它们和语言很好的
集成在一起了， 所以如果你不用true和false来代表其它东西的话，你就不会遇到麻烦。

```
注意： 在比较运算中，正确的大小顺序应该如下：
number < atom > reference < fun < port < pid < tuple < list < bit string

现在你还妹接触到上面所提到的所有类型，但是在阅读完本书之后你将会认识完它们。
现在只需记住这就是为什么你能在任何类型之间进行比较！引用Joe Armstrong的话，
Erlang的创建者之一：“真正的顺序并不重要-但是定义好整体顺序却是重要的。”
```

元组
=======

元组是组织数据的一种方式。它是将数量固定的项式组织在一起的一种方式。在Erlang中，
元组的语法形式为{Element1, Element2, ..., ElementN}。作为一个例子， 假如你给我
一个坐标(x, y)，如果你想告诉我笛卡尔图中一个点的位置。我们可以把这个点表示成两
个项式：

```
1> X = 10, Y = 4.
4
2> Point = {X, Y}.
{10,4}
```
在这种场景中， 一个点总是由两个项式组成。使用元组的方式，我们不用再带着两个项式到处
跑， 我们只需要一个。但是， 如果我收到一个Point变量而我只关心x轴， 这时候该怎么办呢？
这并不是一件很难的事情。让我们开始吧， 开始之前记得使用f() 清除所有的变量。

```
3> Point = {4, 5}.
{4,5}
4> {X, Y} = Point.
{4,5}
5> X.
4
6> {X, _} = Point.
{4,5}
```
从现在开始， 我们可以从X中来拿到元组的第一个元素！但上面的例子是怎么回事呢？起初，X和Y都
没有值， 因此被认为是未绑定变量， 当我们在=操作符左边的元组{X, Y} 里面使用它们的时候, =号
操作符会对两边的值进行比较: {X, Y} vs {4, 5}. Erlang很聪明地将右边元组进行解包并把值分配
给左边的未绑定变量。然后比较就变成了 {4, 5} = {4, 5}， 很明显，这个比较将会成功！ 这是众多
模式匹配中的一种形式。

注意表达式6， 我使用了匿名的_变量。这正是它的使用场景：简单地将值丢弃， 因为我们用不到它。
下划线变量_ 永远是未绑定的，它在模式匹配中被用作通配符。用于元组的模式匹配只有在两边元组
的长度一样时才会成功。

```
8> {_,_} = {4, 5}.
{4,5}
9> {_,_} = {4, 5, 6}.
** exception error: no match of right hand side value {4,5,6}
```
用元组来表示单个值有时候也很有用。最简单的例子就是温度：
```
10> Temprature = 23.213.
23.213
```
好吧， 今天去海滨游玩看起来不错...，等等， 这个温度值的单位是开尔文，摄氏度， 还是是华氏度？

```
11> PreciseTemprature = {celsius, 23.213}.
{celsius,23.213}
12> {kelvin, T} = PreciseTemprature.
** exception error: no match of right hand side value {celsius,23.213}
```
上面的例子抛出了一个错误，但这正是我们所要的！这又是模式匹配在起作用。=操作符最后会比较
{kelvin, T} 和 {celsius, 23.213}：当这个比较发生的时候T还是未绑定的，Erlang发觉原子celsius
和kelvin不能匹配，然后抛出一个异常，后续的代码将得不到执行。通过这种方式， 如果我们的代码期望
的是以Kelvin为单位的温度值，那它将永远不能处理以Celsius为单位的温度值。这样程序员很容易知道
代码之间发送的消息， 这可以辅助调试。以原子开头随后跟着一个元素的元组被称为‘带标签的元组’，
元组里面的元素可以是任何类型，也可以是另一个元组。

```
12> {point, {X, Y}}.
{point,{4,5}}

```
如果我们想存储多个点怎么办？

列表！
==================
列表是很多函数式语言吃饭的家伙。它们被用来解决几乎所有的问题，毫无疑问， 它在Erlang中也是最常用的数据结构。列表可以包含任何东西！
数字， 原子， 元组，其它列表； 它让你用一个数据结构表示所有东西的梦想变得触手可及。列表基本的记法为：[Element1, Element2, ..., ElementN]，你
可以在其中混合存放不同类型的数据：

```
1> [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]
```
很简单对吧？

```
2> [97, 98, 99].
"abc"
```
啊， 不！ 这是Erlang最让人讨厌的地方：字符串！字符串就是列表，它们的记法完全一样！人们为什么不喜欢它呢？请看下面的例子：

```
3> [97, 98, 99, 4, 5, 6]. 
[97,98,99,4,5,6]
4> [233].
"é"
```
Erlang只有在至少有一个元素不能表示成字母的时候才将列表以数字的形式打印出来！Erlang中没有真正的字符串！ 这个问题会在将来一直困扰着你，
而你很有可能因此而憎恨这门语言。不要绝望，因为我们有其它的方式来书写字符串， 我们将会在本章的后续小节介绍这点。

```
不要盲从

这就是你所听到的Erlang在字符串操作上烂透了：它不像其它语言那样有内置的字符串类型。这是因为Erlang最初是为电信公司设计的一门语言。
它们从来不用或者很少使用字符串，所以官方没有考虑过将其加入到语言中。但是，Erlang在字符串处理上的不足正逐步得到改善：
现在虚拟机已经支持Unicode字符串，并且字符串操作正变得越来越快。

我们还可以将字符串以二进制数据结构的形式存储，这让它非常轻量级和高效。总之，标准库里面还是缺少一些和字符串相关的东西，如果你需要
大量的字符串操作， 使用Perl或者Python会更好些。
```
我们使用++来连接列表。与之相反的是我们使用--来将元素从列表中移除：

```
5> [1, 2, 3] ++ [4, 5].
[1,2,3,4,5]
6> [1, 2, 3, 4, 5] -- [1, 2, 3].
[4,5]
7> [2,4,2] -- [2, 4].
[2]
8> [2, 4, 2] -- [2, 4, 2].
[]
```

++ 和 -- 都是右关联的。 这意味着当多个++和--在一起的时候， 计算顺序是从右到左的。就像下面的例子：

```
9> [1, 2, 3] -- [1, 2] -- [3].
[3]
10> [1, 2, 3] -- [1, 2] -- [2].
[2,3]
```
让我们继续。列表的第一元素被称为头（译注：棒打出头鸟，每次受伤的都是它），剩下的被称为尾巴。我们使用两个内置函数来获取它。

```
11> hd([1, 2, 3, 4]).
1
12> tl([1, 2, 3, 4]).
[2,3,4]
```

```
注意：内置函数通常是那些不能用纯Erlang来实现的函数，因此它们是用C或者Erlang的实现语言(80年代的时候是Prolog)来定义的， 
有些函数可以用纯粹的Erlang来实现但是它们仍然使用了C， 以此来获得更高的速度。其中一个例子就是length(List)函数，它会返回
传入list的长度。
```
访问和添加头元素非常快速而高效：当操作列表的时候我们总是首先处理头元素(译注：出头鸟啊。。。)，因为它被如此广泛地使用，Erlang以模式匹配的
方式提供了更为优雅的访问头元素的方法：[Head|Tail]。你可以通过以下方式给列表增加一个头元素:

```
13> List = [2, 3, 4].
[2,3,4]
14> NewList = [1 | List].
[1,2,3,4]
```
当处理列表的时候， 因为总是从头元素开始，所以你需要一种快捷的方式将列表尾存储起来以备后续访问。 如果你记得元组是怎么工作的以及我们怎么
使用模式匹配解包元组point（{X, Y}）的值的话。你就会猜到我们可以使用类似的方式来获取列表的第一个元素（列表头）。

```
15> [Head|Tail] = NewList.
[1,2,3,4]
16> Head.
1
17> Tail.
[2,3,4]
18> [NewHead|NewTail] = Tail.
[2,3,4]
19> NewHead.
2
```
我们使用竖线来表示cons操作符(构造器). 事实上， 任何列表都可以只用cons和值来构造:
```
20> [1 | []].
[1]
21> [2 | [1 | []]].
[2,1]
22> [3 | [2 | [1 | []]]].
[3,2,1]
```
就是说任何列表都可以使用这个公式来构造:[Term1 | [Term2 | [... | [TermN]]]]...。
这样列表就可以使用头加上尾进行递归定义。从这个角度考虑， 我们可以将列表想象
成一条蚯蚓：从中间把它从中间砍断， 你将会得到2条蚯蚓。

对于不熟悉构造器的读者来说， 很容易对Erlang构造列表的方式感到困惑。为了帮助理解这个概念， 请阅读下面的
例子（提示：它们都是等价的）：
```
[a, b, c, d]
[a, b, c, d | []]
[a, b | [c, d]]
[a, b | [c | [d]]]
[a | [b | [c | [d]]]]
[a | [b | [c | [d | [] ]]]]
```
理解了上面这些例子， 你就能够搞定列表推导了。

```
注： [1 | 2] 这样的形式定义了一个“非良构”的列表。在非良构列表上可以使用形如[Head|Tail]这样的模式匹配操作， 
当时不能使用Erlang标准库的函数对它们进行处理， 甚至length()也不行。因为Erlang期望列表都是良构的。良构的列表
都以一个空列表结尾。当我们声明列表 [2]时，它会被自动转化为良构列表。因此, [1 | [2]]是良构的！ 非良构列表尽管
在语法上是正确的， 但它的应用场景在用户自定义的数据结构外却非常罕见。
```






































































































