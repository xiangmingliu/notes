模块
什么是模块
=========

使用交互式的shell在动态语言里面通常被认为是一件非常重要的事情。它在测试各种
程序和代码的时候非常有用。测试Erlang的大部分基本类型不需要打开一个文本编辑
器和保存文件。你可以丢掉你的键盘，跑到外面去打一场球，完成一天的生活，但是
如果就此打住的话你将会是一个糟糕的Erlang程序员。我们需要将代码保存起来以备
将来使用！

这就是模块的作用。模块是将一组函数组织到单个的文件中。另外，Erlang中所有的
函数必须定义在模块中。我们已经使用过模块了， 也许我们还没有意识到这点。前面
章节中提到像hd和tl这样的内置函数， 实际上属于erlang模块，输入这个模块的还有
各种算术运算符， 逻辑运算符和布尔运算符。erlang模块中的的内置函数和其它函数
有所不同， 它们是被自动导入的。如果我们要调用其它模块中的函数， 需要以这种
形式来调用 `Module:Function(Arguments)`。

让我们看看下面的例子：

```
1> erlang:element(2, {a, b, c}).
b
2> lists:seq(1, 4).
[1,2,3,4]
3> seq(1, 4).
** exception error: undefined shell command seq/2
```
我们可以看到， list模块的seq函数没有被自动导入， 但是element函数却被自动
导入了。'undefined shell command'错误是因为shell找不到类似f()这样的命令。
erlang模块中的一些函数也不会被自动导入， 但是它们很少被用到。

从逻辑上说，我们应该将相似的东西放入同一个模块中。比如列表的一般操作被放
在lists模块中，而作输入输出的函数（比如向终端或者文件写内容）则被放在io模
块中。你将会遇到唯一不遵守这条规则的就是前面提到的erlang模块， 它里面有做
数学运算的函数，类型转换的函数，处理多进程的函数，处理虚拟机设置的函数等。
除了都是内置函数外这些函数之间并没有共同点。我们应该避免创建像erlang这样的
模块，而是保持清晰的逻辑划分。

模块声明
========

当编写一个模块的时候， 我们可以声明两类东西：函数和属性。属性是描述模块
自身的元数据， 比如它的名字， 需要被外界访问的函数，代码的作者等等。这些
元数据非常有用， 因为它能够给编译器提供提示信息， 让编译器在不查看源码
就知道如何工作。同时它还让我们能够不看源码就能从编译好的代码中抽取有用
的信息。

目前有大量的属性被使用， 我们也可以声明自己的属性。我们来看一些预定义的属性
所有的模块属性都遵从 `-Name(Attribute).`。这样的属性，其中只有一个是必须的
	-module(Name).
	这个属性必须是文件的第一个属性：它是当前模块的名字，Name是一个原子。
	当从其它模块调用当前模块的函数时，就必须得带上这个名字了。调用的
	形式为 M:F(A)，M为模块名， F为函数，A为参数。

我们来实际操作一下！ 我们的第一个模块非常简单并且没什么用处。 打开你的编辑器
并输入以下内容， 然后将其保存为`useless.erl`:

```
-module(useless).
```

有了这行代码， 我们的文件就是一个合法的模块。真的！尽管因为里面没什么函数，所以
它实际上没什么用。让我们先看看该从这个模块中导出什么函数。为了导出函数，我们需要
另外一个属性：
	-export([Function1/Arity, Function2/Arity,...FunctionN/Arity]).
	这行代码用来定义哪些函数能够从模块外面调用。它接受一个函数列表，每个函数都
	要指明它们的元数。函数的元数是一个代表函数接受多少个参数的整数。这是个很重
	要的信息，因为当且仅当有不同的元数时，一个模块中不同的函数可以有相同的名字。
	函数add(X, Y) 和 add(X, Y, Z)被认为是不同的函数， 相应地它们在导出列表中被
	写为add/2 和 add/3。

```
注意：导出的函数代表一个模块的接口。定义接口的时候只暴露那些使用该模块所必须的
的东西，不要将其它不必要的东西导出模块外， 这点非常重要。这样我们可以随意调整
其它[隐藏]的细节而不会对依赖该模块的其它代码造成影响。
```
我们首先让useless模块导出一个add函数，该函数接受两个参数。我们将下列的导出
属性加入到模块的声明中

```
-export([add/2]).
```
然后编写相应的函数

```
add(A, B) ->
	A + B.
```
函数的语法形式为 `Name(Args) -> Body.`，其中名字必须是一个原子， Body为由逗号
分开的一系列Erlang表达式。函数由（.）号结束。请注意Erlang不使用 ‘return’关键字。
‘return’关键字没有任何用处， 被执行的最后一个表达式的值将会自动返回给调用者。

请添加下面的函数(因为每本关于编程语言的书都需要一个‘Hello World’的例子，就算
我们已经到了第四章！)，别忘了把它添加到导出列表中。

```
%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() -> 
	io:format("Hello World!~n").
```
从这个函数我们可以看到注释是单行的，它以%开头(使用%%只是风格问题)
hello/0也演示了如何从你的模块中调用其它模块的函数。在这个例子中，
io:format/1是输出文本的标准函数。

我们再来添加最后一个函数, 这个函数将会使用add/2 和 hello/0:

```
greet_and_add_two(X) ->
	hello(),
	add(X, 2).
```
不要忘记把greet_and_add_two/1添加到函数导出列表中。hello/0
和add/2函数调用不需要在前面添加模块名，因为它们在同一个模块
中。

如果想像调用hello/0和add/2这样调用io:format/1, 可以添加下列
模块属性到文件的开头: `-import(io, [format/1]).`。然后你就可
以这样`format("Hello World~n").`直接调用了。import语句遵从
下面的形式：
```
-import(Module, [Function1/Arity, ...FunctionN/Arity]).
```
导入函数仅仅是程序员编写代码的一种快捷方式。Erlang程序员不鼓励使用-import属性，因为大家发现它
降低了代码的可读性。如果我们用`io:format/2`做为例子的话情况就很明显了， 因为还存在`io_lib:format/2`。
想弄清楚使用的是哪个函数， 我们必须跑到文件的头部去看到底导入了哪个模块。所以使用模块名进行调用
被认为是一种最佳实践。通常， lists是唯一一个我们使用import属性将它的函数导入的模块：因为它里面的
函数被其它模块使用的频率很高。

我们的useless模块现在看起来应该是下面的样子：
-module(useless).
```
-export([add/2, hello/0, greet_and_add_two/1]).

add(A, B) ->
	A + B.

%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() -> 
	io:format("Hello World!~n").

greet_and_add_two(X) ->
	hello(),
	add(X, 2).
```
我们已经完成了useless模块。你可以将其保存为useless.erl。文件名应该和模块名保持一致，文件以.erl结尾，
这是标准的Erlang源文件的扩展名。

在解释怎么编译模块并尝试其中的函数之前， 我们首先看下怎么定义宏。Erlang宏很类似C的 '#define'语句，
它主要用来定义简短的函数和常量语句，主要用来定义简短的函数和常量。它们会在代码编译之前被展开。
这些宏通常用来避免魔数在你的代码文件里面漫天飞舞。宏被定义成模块的属性，它的形式为
`-define(MACRO, some_value)`。在模块的函数体中我们可以这样`?MACRO`使用它。函数宏可以写成
这样`-define(sub(X, Y), X-Y).`，我们可以这样使用它`?sub(23, 47)`, 它会被编译器展开成`23-47`,
有些人会使用更加复杂的宏， 但是语法是相同的。

编译代码
=========
Erlang代码在被加载到虚拟机之前需要被编译成字节码。你可以在多个地方调用编译器,通过命令行调用`$ erlc flags file.erl`,
在shell或者模块中调用`compile:file(FileName)`, 在shell中使用c()

是时候编译我们的useless模块并尝试它了, 打开Erlang shel，并输入:

```
1> cd("/path/to/where/you/saved/the-module/").
"Path Name to the directory you are in"
ok
```
默认情况下， shell只会在当前路径和标准库路径中寻找文件: cd/1告诉shell切换到一个新的目录中去，
window用户请使用反斜线, 云行了上面的代码后， 接下来我们输入命令：

```
2> c(useless).
{ok,useless}
```
如果你得到了其它的消息， 请确保文件被正确地命名，已经切换到正确的目录中并且模块中没有错误,
成功地编译了文件后，我们将发现目录中多出了一个`useless.beam`文件, 这是已经编译好的模块,
让我们来试试我们的函数:

```
3> useless:add(7,2).
9
4> useless:hello().
Hello, world!
ok
5> useless:greet_and_add_two(-3).
Hello, world!
-1
6> useless:not_a_real_function().
** exception error: undefined function useless:not_a_real_function/0
```
这些函数的输出和我们的预期一样。但是你可能会问为什么hello/0在输出文本后返回了原子ok。这是
因为Erlang的函数和表达式必须总是返回一些东西， 因此， io:format/1返回ok代表正常的条件， 没有错误发生。

表达式6因为函数不存在而抛出了一个错误。如果你忘记把函数导出了， 你将会得到同样的错误。

```
注： 如果你对后缀'.beam'感到好奇, 那我可以告诉你'.beam'代表Bogdan/Björn's Erlang抽象机, 
它本身是个虚拟机. 也存在其它的虚拟机， 但是它们大多数都不在被使用， 已经变成历史了：
JAM:Joe's Abstract Machine, 源于Prolog的[WAM](https://en.wikipedia.org/wiki/Warren_Abstract_Machine)
和老版本的BEAM，它尝试将Erlang代码编译成C代码， 然后再编译成本地机器码。但是基准测试表明并没有
得到太大的性能提升， 因此这个概念后来就被放弃了。
```

有很多编译选项可以指导模块的编译。你可以从[Erlang文档](http://erlang.org/doc/man/compile.html)中
获取完整的选项列表。其中最常用的选项有：
    -debug_info	
    Erlang中很多工具如debugger， 代码覆盖率和静态分析工具会使用这些信息来协助它们的工作。

    -{outdir, Dir}
    Erlang编译器默认情况下会在当前目录中生成BEAM文件，这个选项可以让你选择存放BEAM文件的目录

    -export_all
    加上这个选项后模块里面所有的-export都会被忽略, 模块里面定义的所有函数都会被导出, 这在开发
    和测试新代码的时候很有用， 但是不要在生产环境中这么使用.

    -{d, Macro} 或者 {d, Macro, Value}
    定义一个在模块中可以使用的宏， Macro是一个原子, 这个选项经常在单元测试中用來保証只有在需要
    的時候才會創建模塊中的測試函數並將其導出。如果沒有給出Value的值，它將默認爲'true'。



我們可以使用如下方式來在編譯useless模塊的時候帶上選項：
```
7> compile:file(useless, [debug_info, export_all]).
{ok,useless}
8> c(useless, [debug_info, export_all]).
{ok,useless}
```
你也可以偷偷地在模塊裏面使用模塊屬性來定義編譯選項. 爲了達到第7行和第8行同樣的效果， 我們需要在模塊中
添加以下的代碼：
```
-compile([debug_info, export_all]).
```
然後當我們編譯文件的時候，就能達到手工添加選項的效果. 現在我們已經可以寫函數，編譯和執行牠們，是時候
看看我們能用牠們來做什麼了！

```
註：還有一個選項是將你的Erlang模塊編譯成本地代碼。本地代碼編譯並不支持所有的平臺和操作系統， 但是在
那些支持它的平臺和系統上，它能讓我們的代碼跑得更快（大約快20%, 根據一些正式記載的證據）,爲了能將代碼
編譯成本地機器碼， 我們需要hipe模塊然後以下面的方式調用它：
hipe:c(Module, OptionList). 你也可以使用c(Module, [native]). 請注意生成的.beam文件將包含本地機器碼和
非本地機器碼, 本地機器碼部分將變得不能跨平臺.
```

模塊額外知識
============

在繼續學習更多關於函數和更多有用的代碼片段之前， 讓我們來先來看看一些關於函數的瑣碎的信息，這在將來對
我們可能有所用處。

我們首先關心的是模塊的元數據。我在這章的開頭部分說過模塊的屬性是描述模塊自身的元數據。當訪問不到源文件的
時候我們去哪裏獲取這些信息呢？ 編譯器在這點上爲我們考慮得很周到：當編譯一個模塊的時候， 它會將大部分的模塊
屬性存儲到函數module_info/0中。我們可以使用以下方式來訪問這些元數據：
```
9> useless:module_info().
[{exports,[{add,2},
{hello,0},
{greet_and_add_two,1},
{module_info,0},
{module_info,1}]},
{imports,[]},
{attributes,[{vsn,[174839656007867314473085021121413256129]}]},
{compile,[{options,[]},
{version,"4.6.2"},
{time,{2009,9,9,22,15,50}},
{source,"/home/ferd/learn-you-some-erlang/useless.erl"}]}]
10> useless:module_info(attributes).
[{vsn,[174839656007867314473085021121413256129]}]
```
上面的代碼片斷還演示了另外一個函數，`module_info/1`, 它允許我們獲取關於
某個元數據的信息. 我們可以查看導出的函數（有一個！）， 導入的函數（一個都沒有！），屬性（這是我們
自定義元數據存儲的地方），編譯選項和信息. 如果你在模塊裏面添加了 `-author("An Erlang Champ")`. 我們
將會在vsn相鄰的地方看到它. 生產環境中模塊的屬性沒什麼大的用處， 但是我們可以使用它來玩弄一些小花招以
幫助我們：我在這本書的測試腳本中用它們來註解函數以便更好地進行單元測試; 這個腳本查看模塊的屬性，找到
所有被註解的函數然後顯示相關的告警信息。

```
註： vsn是一個自動生成的唯一值， 對於每個版本來說它們都是不一樣的， 除了註釋以外。它被用在代碼熱加載中
（在一個應用運行的時候對其進行升級而不用將它停止）和一些版本處理工具中。你也可以自己指定vsn的值，只需
添加 `-vsn(VersionNumber)` 到你的模塊中.
```

另一個需要關注的問題是通用模塊設計：避免循環依賴！如果模塊B調用了模塊A， 那模塊A就不應該再調用它。這樣
的調用關係通常讓代碼變得很難維護。事實上， 就算沒有發生循環依賴， 一個模塊依賴太多的模塊也會讓維護工作
變得很困難。如果你寫了這種風格的糟糕代碼， 那你就等着三更半夜被憤怒的工程師或者計算機科學家吵醒吧.

同樣，將功能類似的代碼重新組織到一起被認爲是一種最佳實踐。啓動或停止一個應用，創建或者刪除數據庫中的一條
記錄就是這個場景下的例子。

好吧， 學問也賣弄得差不多了。接下來我們將探索Erlang中哪方面的內容呢？























































