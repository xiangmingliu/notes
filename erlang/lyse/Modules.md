模块
什么是模块
=========

使用交互式的shell在动态语言里面通常被认为是一件非常重要的事情。它在测试各种
程序和代码的时候非常有用。测试Erlang的大部分基本类型不需要打开一个文本编辑
器和保存文件。你可以丢掉你的键盘，跑到外面去打一场球，完成一天的生活，但是
如果就此打住的话你将会是一个糟糕的Erlang程序员。我们需要将代码保存起来以备
将来使用！

这就是模块的作用。模块是将一组函数组织到单个的文件中。另外，Erlang中所有的
函数必须定义在模块中。我们已经使用过模块了， 也许我们还没有意识到这点。前面
章节中提到像hd和tl这样的内置函数， 实际上属于erlang模块，输入这个模块的还有
各种算术运算符， 逻辑运算符和布尔运算符。erlang模块中的的内置函数和其它函数
有所不同， 它们是被自动导入的。如果我们要调用其它模块中的函数， 需要以这种
形式来调用 `Module:Function(Arguments)`。

让我们看看下面的例子：

```
1> erlang:element(2, {a, b, c}).
b
2> lists:seq(1, 4).
[1,2,3,4]
3> seq(1, 4).
** exception error: undefined shell command seq/2
```
我们可以看到， list模块的seq函数没有被自动导入， 但是element函数却被自动
导入了。'undefined shell command'错误是因为shell找不到类似f()这样的命令。
erlang模块中的一些函数也不会被自动导入， 但是它们很少被用到。

从逻辑上说，我们应该将相似的东西放入同一个模块中。比如列表的一般操作被放
在lists模块中，而作输入输出的函数（比如向终端或者文件写内容）则被放在io模
块中。你将会遇到唯一不遵守这条规则的就是前面提到的erlang模块， 它里面有做
数学运算的函数，类型转换的函数，处理多进程的函数，处理虚拟机设置的函数等。
除了都是内置函数外这些函数之间并没有共同点。我们应该避免创建像erlang这样的
模块，而是保持清晰的逻辑划分。

模块声明
========

当编写一个模块的时候， 我们可以声明两类东西：函数和属性。属性是描述模块
自身的元数据， 比如它的名字， 需要被外界访问的函数，代码的作者等等。这些
元数据非常有用， 因为它能够给编译器提供提示信息， 让编译器在不查看源码
就知道如何工作。同时它还让我们能够不看源码就能从编译好的代码中抽取有用
的信息。

目前有大量的属性被使用， 我们也可以声明自己的属性。我们来看一些预定义的属性
所有的模块属性都遵从 `-Name(Attribute).`。这样的属性，其中只有一个是必须的
	-module(Name).
	这个属性必须是文件的第一个属性：它是当前模块的名字，Name是一个原子。
	当从其它模块调用当前模块的函数时，就必须得带上这个名字了。调用的
	形式为 M:F(A)，M为模块名， F为函数，A为参数。

我们来实际操作一下！ 我们的第一个模块非常简单并且没什么用处。 打开你的编辑器
并输入以下内容， 然后将其保存为`useless.erl`:

```
-module(useless).
```

有了这行代码， 我们的文件就是一个合法的模块。真的！尽管因为里面没什么函数，所以
它实际上没什么用。让我们先看看该从这个模块中导出什么函数。为了导出函数，我们需要
另外一个属性：
	-export([Function1/Arity, Function2/Arity,...FunctionN/Arity]).
	这行代码用来定义哪些函数能够从模块外面调用。它接受一个函数列表，每个函数都
	要指明它们的元数。函数的元数是一个代表函数接受多少个参数的整数。这是个很重
	要的信息，因为当且仅当有不同的元数时，一个模块中不同的函数可以有相同的名字。
	函数add(X, Y) 和 add(X, Y, Z)被认为是不同的函数， 相应地它们在导出列表中被
	写为add/2 和 add/3。

```
注意：导出的函数代表一个模块的接口。定义接口的时候只暴露那些使用该模块所必须的
的东西，不要将其它不必要的东西导出模块外， 这点非常重要。这样我们可以随意调整
其它[隐藏]的细节而不会对依赖该模块的其它代码造成影响。
```
我们首先让useless模块导出一个add函数，该函数接受两个参数。我们将下列的导出
属性加入到模块的声明中

```
-export([add/2]).
```
然后编写相应的函数

```
add(A, B) ->
	A + B.
```
函数的语法形式为 `Name(Args) -> Body.`，其中名字必须是一个原子， Body为由逗号
分开的一系列Erlang表达式。函数由（.）号结束。请注意Erlang不使用 ‘return’关键字。
‘return’关键字没有任何用处， 被执行的最后一个表达式的值将会自动返回给调用者。

请添加下面的函数(因为每本关于编程语言的书都需要一个‘Hello World’的例子，就算
我们已经到了第四章！)，别忘了把它添加到导出列表中。

```
%% Shows greetings.
%% io:format/1 is the standard function used to output text.
hello() -> 
	io:format("Hello World!~n").
```
从这个函数我们可以看到注释是单行的，它以%开头(使用%%只是风格问题)
hello/0也演示了如何从你的模块中调用其它模块的函数。在这个例子中，
io:format/1是输出文本的标准函数。

我们再来添加最后一个函数, 这个函数将会使用add/2 和 hello/0:

```
greet_and_add_two(X) ->
	hello(),
	add(X, 2).
```
不要忘记把greet_and_add_two/1添加到函数导出列表中。hello/0
和add/2函数调用不需要在前面添加模块名，因为它们在同一个模块
中。

如果想像调用hello/0和add/2这样调用io:format/1, 可以添加下列
模块属性到文件的开头: `-import(io, [format/1]).`。然后你就可
以这样`format("Hello World~n").`直接调用了。import语句遵从
下面的形式：








































